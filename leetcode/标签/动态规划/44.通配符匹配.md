### 初解
##### 想法
第一个想法遍历partten去匹配,不断回溯.  
第二个想法是用递归方式,但是用时超过了限制.  
第三个想法想到了备忘录方法//动态规划
##### 算法
```java
class Solution {
    Boolean[][] book;

    public boolean isMatch(String s, String p) {
        if (book == null) {
            book = new Boolean[p.length() + 1][s.length() + 1];
        }
        if (book[p.length()][s.length()] != null) {
            return book[p.length()][s.length()];
        }
        if (p.length() == 0) {
            book[p.length()][s.length()] = s.length() == 0;
            return book[p.length()][s.length()];
        }
        if (p.charAt(0) == '*') {
            if (p.length() == 1) {
                book[p.length()][s.length()] = true;
                return book[p.length()][s.length()];
            }
            if (p.length() > 1 && p.charAt(1) == '*') {
                book[p.length()][s.length()] = isMatch(s, p.substring(1));
                return book[p.length()][s.length()];
            }
            for (int i = s.length() - 1; i >= 0; i--) {
                if (p.charAt(1) != s.charAt(i) && p.charAt(1) != '?')
                    continue;
                if (isMatch(s.substring(i), p.substring(1))) {
                    book[p.length()][s.length()] = true;
                    return book[p.length()][s.length()];
                }
            }
            return false;
        }
        if (s.length() == 0) {
            book[p.length()][s.length()] = false;
            return book[p.length()][s.length()];
        }
        if (p.charAt(0) == s.charAt(0) || p.charAt(0) == '?') {
            book[p.length()][s.length()] = isMatch(s.substring(1), p.substring(1));
            return book[p.length()][s.length()];
        }
        return false;
    }
}
```
##### 复杂度分析
时间复杂度：267ms
空间复杂度：50MB


### 优化解
##### 想法
动态规划,先把表列出来
自底向上求表
1. book[0][0] = false//p,s都为空
2. book[i][0] = p[i-1]=='*' && book[i-1][0]//s为空,只有p的前一个为\*并且匹配才行
3. book[0][j] = false //p为空,s不为空
4. 如果p[i]=='?'||s[j]==p[i],则book[i][j] = book[i-1][j-1] //如果前面匹配,当前字母也匹配
5. 如果p[i]=='*',则book[i][j] = book[i-1][j]|book[i][j-1] //如果为\*,book[i-1][j]表示\*匹配了空,book[i][j-1]表示匹配了非空任何字符
##### 算法
```java

```
##### 复杂度分析
时间复杂度：
空间复杂度：

### 最优解
##### 想法
##### 算法
```java

```
##### 复杂度分析
时间复杂度：
空间复杂度：