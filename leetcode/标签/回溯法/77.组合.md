1. 暴力失败

2. 深度优先算法
    ```java
    class Solution {
        List<List<Integer>> result = new ArrayList<List<Integer>>();

        public List<List<Integer>> combine(int n, int k) {
            //缺少判断条件
            dfs(n, k, 1, new Stack<Integer>());
            return result;
        }

        public void dfs(int n, int k, int start, Stack<Integer> Item) {
            //应该先判断递归结束

            //然后循环递归
            for (; start <= n; start++) {
                Item.push(start);
                if (Item.size() == k) {
                    result.add(new ArrayList<Integer>(Item));
                    Item.pop();
                    continue;
                }
                dfs(n, k, start + 1, Item);
                Item.pop();
            }
        }
    }
    ```
    改正后
    ```java
    class Solution {
        List<List<Integer>> result = new ArrayList<List<Integer>>();

        public List<List<Integer>> combine(int n, int k) {
            if (n <= 0 || k <= 0 || n < k) {
                return result;
            }
            dfs(n, k, 1, new Stack<Integer>());
            return result;
        }

        public void dfs(int n, int k, int start, Stack<Integer> Item) {
            if (Item.size() == k) {
                result.add(new ArrayList<Integer>(Item));
                return;
            }

            for (int i = start; i <= n; i++) {
                Item.push(i);
                dfs(n, k, i + 1, Item);
                Item.pop();
            }
        }
    }
    ```
